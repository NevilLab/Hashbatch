Estimation of exclusive, x.
Then from there, estimation of y.

Load packages.

Figure 2.

Load packages.
```{r message=FALSE}
library(Seurat)
library(hdf5r)
library(openxlsx)
library(stringr)
library(purrr)
library(ggplot2)
library(ggpubr)

#library(future)
#options(future.globals.maxSize = 50*1e9)

options(Seurat.object.assay.version = 'v5')

Total <- c() # Total number of cells
After_cleanup <- c() # After mito/feature/count clean up 
After_demux <- c() # After cleanup and demultiplexing
po_ol <- c() # keep a record of the tissue
idx <- c() # Record index
```

Run through the wells and find the positive cells for each hash.
```{r}
setwd("../hash_well_data")
labl_hsh <- read.xlsx('HW_des.xlsx')
ind_adt <- read.xlsx('adt_ind.xlsx', colNames = FALSE)

atoms <- list()
n <- 1
G_D_E <- c()
I_H_E <- list()
Dual_GDE <- c()
Vlns_count <- list()
Vlns_feature <- list()
Q3D_c <- c()
Q3D_f <- c()
setwd('./h5')
for (j in 1:6) { #:16
  D.data <- Read10X_h5(paste('./', labl_hsh$Label[j], '.h5', sep = ""))
  k1 <- str_split(labl_hsh$hashtags_pick[j], " ") # pick up the hashes
  k2 <- as.numeric(k1[[1]])
  k3 <- str_split(ind_adt[1,1], ", ") # pick up the ADT indexes
  k4 <- as.numeric(k3[[1]])
  
  rna.counts <- D.data$`Gene Expression` # Call the data
  hto.counts <- D.data$`Antibody Capture`[k2 + 192, ]
  adt.counts <- D.data$`Antibody Capture`[k4, ] 
  
  D.data.joint <- intersect(colnames(rna.counts), colnames(hto.counts)) # Make sure overlapping counts are called
  D.data.joint <- intersect(colnames(rna.counts), colnames(adt.counts))
  rna.counts <- rna.counts[, D.data.joint]
  hto.counts <- hto.counts[, D.data.joint]
  adt.counts <- adt.counts[, D.data.joint]
  
  # Create Seurat object
  D <- CreateSeuratObject(counts = rna.counts, project = labl_hsh[j,1], assay = "RNA") # Create Seurat object
  D[["percent.mt"]] <- PercentageFeatureSet(D, pattern = "^mt-")
  
  D[["HTO"]] <- CreateAssayObject(counts = hto.counts)
  D <- NormalizeData(D, assay = "HTO", normalization.method = "CLR", verbose = FALSE) # Normalise the HTO
  D[["ADT"]] <- CreateAssayObject(counts = adt.counts)
  D <- NormalizeData(D, assay = "ADT", normalization.method = "CLR", verbose = TRUE) # NOrmalise ADT
  
  # Record the total number of cells
  Total <- c(Total, dim(D)[2])
  
  # Rename cells to avoid future conflicts
  dataset_name <- paste(labl_hsh[j,4], labl_hsh[j,1], sep = "_")
  D$dataset <- dataset_name
  D <- RenameCells(object = D, add.cell.id = dataset_name)
  
  # Cleanup 
  D <- subset(D, subset = nFeature_RNA > 500 & nFeature_RNA < 3000 & percent.mt < 2.5 & nCount_RNA < 20000) 
  
  # Record the number of cells after cleanup
  After_cleanup <- c(After_cleanup, dim(D)[2])
  
  # Demultiplexing (Seurat)
  D <- HTODemux(D, assay = "HTO", verbose = TRUE) # Demultiplex positive.quantile is at default
  
  # Pickup Seurat hash thresholds
  quiet_demux <- quietly(HTODemux)
  b <- quiet_demux(D)
  Seurat_thresh <- c()
  for (p in 1:length(b$messages)) {
    temp_string <- str_split(b$messages[p], " ")
    Seurat_thresh <- c(Seurat_thresh, as.numeric(temp_string[[1]][5]))
  }
  # Global demux efficacy (GDE) <- singlet/all
  temp_table <- table(D$HTO_classification.global)
  GDE <- temp_table[["Singlet"]]/dim(D)[2]
  
  # Individual hash efficiency (IHE) <- hash_singlet/hash_positive
  
  hto_data <- GetAssayData(object = D, assay = "HTO", layer = "count")
  hash_positive <- c()
  for (q in 1:length(Seurat_thresh)) {
    hash_positive <- c(hash_positive, length(which(hto_data[q,] > Seurat_thresh[q])))
  }
  
  
  # Record the number of cells after demultiplexing
  After_demux <- c(After_demux, dim(D.singlet)[2])
  
  # Annotate samples on tissue
  D@meta.data$pool = labl_hsh[j,4]
  
  #Keep the demultiplexed, normalized data in the list
  atoms[[n]] <- D
  n <- n + 1

  po_ol <- c(po_ol, labl_hsh[j,4]) # keep a record of the pool
  idx <- c(idx, labl_hsh[j,1]) # Record index
  
}
```

Now attempt solving y. 
A function for y estimation. 
```{r}
solve_y <- function(x, n, E) {
  stopifnot(n >= 3, x > 0, x < 1,
            E <= 1 - x + 1e-12,
            E >= 1 - x*(n-1) - 1e-12)
  g <- function(y) 1 - x*y + x*y*(1 - 1/y)^(n-1) - E
  uniroot(g, c(1 + 1e-9, 1e9))$root
}
```

Solve y for the different scenarios/datasets.
Hash3. poolA.
Hash7. PoolD.
Hash12. poolF.
Hash1. 8 hash data, RSatija.
```{r}
#Hash3. poolA.
solve_y(x, n, E)

#Hash7. PoolD.
solve_y(x, n, E)

#Hash12. poolF.
solve_y(x, n, E)

#Hash1. 8 hash data, RSatija.
solve_y(x, n, E)
```

Plot bardiagrams with error bars.
```{r}

```



