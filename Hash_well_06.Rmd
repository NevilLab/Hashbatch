Estimation of exclusive, x.
Then from there, estimation of y.

Load packages.

Figure 2.

Load packages.
```{r message=FALSE}
library(Seurat)
library(hdf5r)
library(openxlsx)
library(stringr)
library(purrr)
library(ggplot2)
library(ggpubr)

#library(future)
#options(future.globals.maxSize = 50*1e9)

options(Seurat.object.assay.version = 'v5')

```

Run through the wells and find the positive cells for each hash.
```{r}
setwd("../hash_well_data")
labl_hsh <- read.xlsx('HW_des.xlsx')
ind_adt <- read.xlsx('adt_ind.xlsx', colNames = FALSE)

atoms <- list()
n <- 1
positive_cells <- list()
setwd('./h5')
for (j in 1:6) { #:16
  D.data <- Read10X_h5(paste('./', labl_hsh$Label[j], '.h5', sep = ""))
  k1 <- str_split(labl_hsh$hashtags_pick[j], " ") # pick up the hashes
  k2 <- as.numeric(k1[[1]])
  k3 <- str_split(ind_adt[1,1], ", ") # pick up the ADT indexes
  k4 <- as.numeric(k3[[1]])
  
  rna.counts <- D.data$`Gene Expression` # Call the data
  hto.counts <- D.data$`Antibody Capture`[k2 + 192, ]
  adt.counts <- D.data$`Antibody Capture`[k4, ] 
  
  D.data.joint <- intersect(colnames(rna.counts), colnames(hto.counts)) # Make sure overlapping counts are called
  D.data.joint <- intersect(colnames(rna.counts), colnames(adt.counts))
  rna.counts <- rna.counts[, D.data.joint]
  hto.counts <- hto.counts[, D.data.joint]
  adt.counts <- adt.counts[, D.data.joint]
  
  # Create Seurat object
  D <- CreateSeuratObject(counts = rna.counts, project = labl_hsh[j,1], assay = "RNA") # Create Seurat object
  D[["percent.mt"]] <- PercentageFeatureSet(D, pattern = "^mt-")
  
  D[["HTO"]] <- CreateAssayObject(counts = hto.counts)
  D <- NormalizeData(D, assay = "HTO", normalization.method = "CLR", verbose = FALSE) # Normalise the HTO
  D[["ADT"]] <- CreateAssayObject(counts = adt.counts)
  D <- NormalizeData(D, assay = "ADT", normalization.method = "CLR", verbose = TRUE) # NOrmalise ADT
  
  # Rename cells to avoid future conflicts
  dataset_name <- paste(labl_hsh[j,4], labl_hsh[j,1], sep = "_")
  D$dataset <- dataset_name
  D <- RenameCells(object = D, add.cell.id = dataset_name)
  
  # Cleanup 
  D <- subset(D, subset = nFeature_RNA > 500 & nFeature_RNA < 3000 & percent.mt < 2.5 & nCount_RNA < 20000) 
  
  # Demultiplexing (Seurat)
  D <- HTODemux(D, assay = "HTO", verbose = TRUE) # Demultiplex positive.quantile is at default
  
  # Pickup Seurat hash thresholds
  quiet_demux <- quietly(HTODemux)
  b <- quiet_demux(D)
  Seurat_thresh <- c()
  for (p in 1:length(b$messages)) {
    temp_string <- str_split(b$messages[p], " ")
    Seurat_thresh <- c(Seurat_thresh, as.numeric(temp_string[[1]][5]))
  }
  # Global demux efficacy (GDE) <- singlet/all
  temp_table <- table(D$HTO_classification.global)
  GDE <- temp_table[["Singlet"]]/dim(D)[2]
  
  # cell ids of +ve cells
  hto_data <- GetAssayData(object = D, assay = "HTO", layer = "count")
  hash_positive <- list()
  for (q in 1:length(Seurat_thresh)) {
    hash_positive[[q]] <- hto_data[q, which(hto_data[q,] > Seurat_thresh[q])]
  }
  
  positive_cells[[j]] <- hash_positive
  
  Idents(D) <- "HTO_classification.global" 
  D.singlet <- subset(D, idents = "Singlet")
  
  atoms[[j]] <- D.singlet
}
```
Write a function to calculate x.
```{r}
XE_calc <- function(object, foucus_hash) {
#object <- positive_cells[[1]]
#focus_hash <- 3

outlist <- list()
X <- c()

collect <- c()
for (i in setdiff(1:length(object), focus_hash)) {
  temp_string1 <- names(object[[focus_hash]])

  temp_string2 <- names(object[[i]])
  
  X <- c(X, length(intersect(temp_string1, temp_string2))/length(temp_string1))
  
  collect <- c(collect, intersect(temp_string1, temp_string2))
}

E <- length(setdiff(temp_string1, collect))/length(temp_string1)

outlist[["X"]] <- X
outlist[["E"]] <- E

return(outlist)
}
```

Now attempt solving y. 
A function for y estimation. 
```{r}
solve_y <- function(x, hash, n, E) {
  stopifnot(n >= 3, x[hash] > 0, x[hash] < 1,
            E <= 1 - x[hash] + 1e-12,
            E >= 1 - sum(x) - 1e-12)
  g <- function(y) 1 - x[hash]*y + x[hash]*y*(1 - 1/y)^(n-1) - E
  uniroot(g, c(1 + 1e-9, 1e9))$root
}
```

Calculate E, x now.
```{r}
#Hash4. poolA.
object <- positive_cells[[1]]
focus_hash <- 4
outA4 <- XE_calc(object, foucus_hash)
#solve_y(outA3[["X"]], 1, 4, outA3[["E"]])
#solve_y(outA3[["X"]], 2, 4, outA3[["E"]])
solve_y(outA4[["X"]], 3, 4, outA4[["E"]])

#Hash8. PoolC.
object <- positive_cells[[3]]
focus_hash <- 4
outC8 <- XE_calc(object, foucus_hash)
#solve_y(outD9[["X"]], 1, 4, outD9[["E"]])
#solve_y(outD9[["X"]], 2, 4, outD9[["E"]])
solve_y(outC8[["X"]], 3, 4, outC8[["E"]])

#Hash14. PoolE.
object <- positive_cells[[5]]
focus_hash <- 4
outE14 <- XE_calc(object, foucus_hash)
#solve_y(outD9[["X"]], 1, 4, outD9[["E"]])
#solve_y(outD9[["X"]], 2, 4, outD9[["E"]])
solve_y(outE14[["X"]], 3, 4, outE14[["E"]])


#Hash4. poolF.
object <- positive_cells[[6]]
focus_hash <- 4
outF4 <- XE_calc(object, foucus_hash)
solve_y(outF4[["X"]], 1, 12, outF4[["E"]])

#Hash8. poolF.
object <- positive_cells[[6]]
focus_hash <- 8
outF8 <- XE_calc(object, foucus_hash)
solve_y(outF8[["X"]], 1, 12, outF8[["E"]])
```

Plot bardiagrams of x% from F.
```{r}
df <- data.frame(1:11, outF4$X)
colnames(df) <- c("serial", "x")
ggplot(df, aes(serial, x)) + geom_bar(stat="identity") + theme_bw() + NoLegend() +
  theme(panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  axis.text = element_blank()) +
  theme(axis.title = element_blank())

df <- data.frame(1:11, outF8$X)
colnames(df) <- c("serial", "x")
ggplot(df, aes(serial, x)) + geom_bar(stat="identity") + theme_bw() + NoLegend() +
  theme(panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  axis.text = element_blank()) +
  theme(axis.title = element_blank())
```



