This markdown integrates the different sets within the hash_well dataset.
The description of the sets are in the figure 1A of the manuscript.
It covers different types of integration as provided by Seurat 5:
CCAIntegration, RPCAIntegration, HarmonyIntegration, FastMNNIntegration, scVIIntegration
It also carries out cell clustering on the reductions.

All data are read from and saved at a different directory to keep the repository light.

Load packages.
```{r message=FALSE}
library(Seurat)
library(hdf5r)
library(openxlsx)
library(stringr)

library(future)
options(future.globals.maxSize = 50*1e9)

options(Seurat.object.assay.version = 'v5')
```

Function to remove TCR and BCR genes.
```{r}
filterTCRBCR <- function(rnacounts) {
#rnacounts <- rna.counts

Ighv <- grep('Ighv',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Ighd <- grep('Ighd',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Ighj <- grep('Ighj',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Igkv <- grep('Igkv',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Igkj <- grep('Igkj',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Iglv <- grep('Iglv',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Iglj <- grep('Iglj',rnacounts@Dimnames[[1]], ignore.case = FALSE)

# Collect the indexes to remove Tra, Trb, Trg and Trd genes
Trav <- grep('Trav',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Traj <- grep('Traj',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trbv <- grep('Trbv',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trbd <- grep('Trbd',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trbj <- grep('Trbj',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trgv <- grep('Trgv',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trgj <- grep('Trgj',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trdv <- grep('Trdv',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trdd <- grep('Trdd',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trdj <- grep('Trdj',rnacounts@Dimnames[[1]], ignore.case = FALSE)

# Collect the indexes to remove constant region genes
Igha <- grep('Igha',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Ighe <- grep('Ighe',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Ighd <- grep('Ighd',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Ighg <- grep('Ighg',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Ighm <- grep('Ighm',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Ighm <- Ighm[1]
Igkc <- grep('Igkc',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Iglc <- grep('Iglc',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trac <- grep('Trac',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trbc <- grep('Trbc',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Tcrg <- grep('Tcrg',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Trdc <- grep('Trdc',rnacounts@Dimnames[[1]], ignore.case = FALSE)
# Collect the indexes to remove mitochondrial genes
mt <- grep('mt-',rnacounts@Dimnames[[1]], ignore.case = FALSE)
# Collect the indexes to remove ribosomal genes
Rpl <- grep('Rpl',rnacounts@Dimnames[[1]], ignore.case = FALSE)
Rps <- grep('Rps',rnacounts@Dimnames[[1]], ignore.case = FALSE)

# Remove Igh, Igk, Igl and Tra, Trb, Trg, Trd from RNA
rnacounts <- rnacounts[-c(Ighv, Ighd, Ighj, Igkv, Igkj, Iglv, Iglj,
                                  Trav, Traj, Trbv, Trbd, Trbj, Trgv, Trgj, 
                                  Trdv, Trdd, Trdj,
                                  Igha, Ighe, Ighd, Ighg, Ighm, 
                                  Igkc, Iglc, Trac, Trbc, Tcrg, 
                                  Trdc, mt, Rpl, Rps),]

return(rnacounts)
}
```

Read files, demultiplex and merge objects.
Clear everything from memory other than the merged object.
```{r message=FALSE}
setwd("../hash_well_data")
labl_hsh <- read.xlsx('HW_des.xlsx')
ind_adt <- read.xlsx('adt_ind.xlsx', colNames = FALSE)


setwd('./h5')
for (j in 1:6) {
  D.data <- Read10X_h5(paste('./', labl_hsh$Label[j], '.h5', sep = ""))
  k1 <- str_split(labl_hsh$hashtags_pick[j], " ") # pick up the hashes
  k2 <- as.numeric(k1[[1]])
  k3 <- str_split(ind_adt[1,1], ", ") # pick up the ADT indexes
  k4 <- as.numeric(k3[[1]])
 
  rna.counts <- D.data$`Gene Expression` # Call the data
  hto.counts <- D.data$`Antibody Capture`[k2 + 192, ]
  adt.counts <- D.data$`Antibody Capture`[k4, ]
 
  D.data.joint <- intersect(colnames(rna.counts), colnames(hto.counts)) # Make sure overlapping counts
  D.data.joint <- intersect(colnames(rna.counts), colnames(adt.counts))
  rna.counts <- rna.counts[, D.data.joint]
  hto.counts <- hto.counts[, D.data.joint]
  adt.counts <- adt.counts[, D.data.joint]
  
  # Single line removal of TCR BCR genes
  rna.counts <- filterTCRBCR(rna.counts)
  
  # Create Seurat object
  D <- CreateSeuratObject(counts = rna.counts, project = labl_hsh$Label[j], assay = "RNA") # Seurat object
  D[["percent.mt"]] <- PercentageFeatureSet(D, pattern = "^mt-")
 
  D[["HTO"]] <- CreateAssayObject(counts = hto.counts)
  D <- NormalizeData(D, assay = "HTO", normalization.method = "CLR", verbose = FALSE) # Normalise the HTO
  D[["ADT"]] <- CreateAssayObject(counts = adt.counts)
  D <- NormalizeData(D, assay = "ADT", normalization.method = "CLR", verbose = TRUE) # NOrmalise ADT
  
  # Rename cells to avoid future conflicts
  D$dataset <- labl_hsh$Label[j]
  D <- RenameCells(object = D, add.cell.id = labl_hsh$Label[j])

  # Cleanup
  D <- subset(D, subset = nFeature_RNA > 500 & nFeature_RNA < 3000 & percent.mt < 2.5 & nCount_RNA < 20000)

 # Demultiplexing
  D <- HTODemux(D, assay = "HTO", positive.quantile = 0.99, verbose = TRUE) # Demultiplex
  Idents(D) <- "HTO_classification.global"
  D.singlet <- subset(D, idents = "Singlet")
  
  #SCtransform
  #D.singlet <- SCTransform(D.singlet, vst.flavor = "v2", verbose = FALSE)

  # Annotate samples following the hashtags
  D.singlet@meta.data$orig.id = ""
  for(k in unique(D.singlet@meta.data$HTO_maxID)){
  if (nchar(k) == 12) {
    D.singlet@meta.data$orig.id[D.singlet@meta.data$HTO_maxID == k] = as.character(
                                                  paste(strsplit(labl_hsh[j,1], split = "_")[[1]][2], 
                                                  'H0',gsub("Ms.Hashtag-", "", k), sep = ""))
  }
  if (nchar(k) == 13) {
    D.singlet@meta.data$orig.id[D.singlet@meta.data$HTO_maxID == k] = as.character(
                                                  paste(strsplit(labl_hsh[j,1], split = "_")[[1]][2], 
                                                  'H', gsub("Ms.Hashtag-", "", k), sep = ""))
  }
}

  if (j == 1) {
    mObject <- D.singlet
  }
  if (j > 1)
    mObject <- merge(mObject, D.singlet)
}
```
Clear memory first.
```{r}
rm(list = setdiff(ls(), "mObject"))
```

Then define two function for running the following integrations:
On RNA (RNAfunction):
CCAIntegration, RPCAIntegration, HarmonyIntegration (also calculates the unintegrated)
On SCT (SCTfunction):
RPCAIntegration, HarmonyIntegration

Runs neighbor search and clustering on each (with PC=50, Res=1)
Then generates the UMAPs.

RNAfunction.
```{r}
RNAfunction <- function(mObject) {
# Join and split to correctly name the layers  
DefaultAssay(mObject) <- "RNA"
mObject <- JoinLayers(mObject)
mObject[["RNA"]] <- split(mObject[["RNA"]], f = mObject$dataset)
# Unintegrated Normalized RNA
mObject <- NormalizeData(mObject)
mObject <- FindVariableFeatures(mObject, nfeatures = 3000)
mObject <- ScaleData(mObject)
mObject <- RunPCA(mObject, verbose = FALSE) 

mObject <- FindNeighbors(mObject, dims = 1:50, reduction = "pca")
mObject <- FindClusters(mObject, resolution = 1, cluster.name = "unint_clusters")
mObject <- RunUMAP(mObject, reduction = "pca", dims = 1:50, reduction.name = "umap.unint")
# CCA integration
mObject <- IntegrateLayers(object = mObject, method = CCAIntegration,
                       orig.reduction = "pca", new.reduction = "integrated.cca",
                       assay = "RNA", verbose = FALSE)

mObject <- FindNeighbors(mObject, dims = 1:50, reduction = "integrated.cca")
mObject <- FindClusters(mObject, resolution = 1, cluster.name = "cca_clusters")
mObject <- RunUMAP(mObject, reduction = "integrated.cca", dims = 1:50, reduction.name = "umap.cca")
# Harmony integration
mObject <- IntegrateLayers(object = mObject, method = HarmonyIntegration,
                       orig.reduction = "pca", new.reduction = "harmony",
                       assay = "RNA", verbose = FALSE)

mObject <- FindNeighbors(mObject, dims = 1:50, reduction = "harmony")
mObject <- FindClusters(mObject, resolution = 1, cluster.name = "harmony_clusters")
mObject <- RunUMAP(mObject, reduction = "harmony", dims = 1:50, reduction.name = "umap.harmony")
# RPCA integration
mObject <- IntegrateLayers(object = mObject, method = RPCAIntegration,
                       orig.reduction = "pca", new.reduction = "integrated.rpca",
                       assay = "RNA", verbose = FALSE)

mObject <- FindNeighbors(mObject, dims = 1:50, reduction = "integrated.rpca")
mObject <- FindClusters(mObject, resolution = 1, cluster.name = "rpca_clusters")
mObject <- RunUMAP(mObject, reduction = "integrated.rpca", dims = 1:50, reduction.name = "umap.rpca")

mObject <- JoinLayers(mObject)
return(mObject)
}
```
SCTfunction.
```{r message=FALSE}
SCTfunction <- function(mObject) {
DefaultAssay(mObject) <- "RNA"
mObject <- JoinLayers(mObject)
mObject[["RNA"]] <- split(mObject[["RNA"]], f = mObject$dataset)

mObject <- SCTransform(mObject, verbose = FALSE, vst.flavor = 'v2')  

mObject[["SCT"]] <- split(mObject[["SCT"]], f = mObject$dataset)
mObject <- JoinLayers(mObject)
mObject[["SCT"]] <- split(mObject[["SCT"]], f = mObject$dataset)

mObject <- RunPCA(mObject, npcs = 50, verbose = FALSE)  

mObject <- IntegrateLayers(object = mObject, method = HarmonyIntegration,
                       orig.reduction = "pca", new.reduction = "harmony",
                       assay = "SCT", verbose = FALSE)

mObject <- FindNeighbors(mObject, reduction = "harmony", dims = 1:50)
mObject <- FindClusters(mObject, resolution = 1, cluster.name = "harmony_clusters")
mObject <- RunUMAP(mObject, reduction = "harmony", dims = 1:50, reduction.name = "umap.harmony")

mObject <- IntegrateLayers(object = mObject, method = RPCAIntegration,
                       orig.reduction = "pca", new.reduction = "integrated.rpca",
                       assay = "SCT", verbose = FALSE)

mObject <- FindNeighbors(mObject, reduction = "integrated.rpca", dims = 1:50)
mObject <- FindClusters(mObject, resolution = 1, cluster.name = "rpca_clusters")
mObject <- RunUMAP(mObject, reduction = "integrated.rpca", dims = 1:50, reduction.name = "umap.rpca")

mObject <- IntegrateLayers(object = mObject, method = CCAIntegration,
                       orig.reduction = "pca", new.reduction = "integrated.cca",
                       assay = "SCT", verbose = FALSE)

mObject <- FindNeighbors(mObject, reduction = "integrated.cca", dims = 1:50)
mObject <- FindClusters(mObject, resolution = 1, cluster.name = "cca_clusters")
mObject <- RunUMAP(mObject, reduction = "integrated.cca", dims = 1:50, reduction.name = "umap.cca")

mObject <- JoinLayers(mObject)
return(mObject)
}
```

hash_well_I <- all six wells (mObject)
```{r message=FALSE}
hash_well_I <- mObject

hash_well_I_RNA <- RNAfunction(hash_well_I)
hash_well_I_SCT <- SCTfunction(hash_well_I)

setwd("../hash_well_data/SObjects")
SaveSeuratRds(hash_well_I_RNA, file = "hash_well_I_RNA.RDS")
SaveSeuratRds(hash_well_I_SCT, file = "hash_well_I_SCT.RDS")
rm(list = setdiff(ls(), c("mObject", "RNAfunction", "SCTfunction")))
```

hash_well_II <- only control cells from six wells
```{r}
hash_well_II <- mObject

hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-3")
hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-4")
hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-5")
hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-6")
hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-7")
hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-8")
hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-9")
hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-12")
hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-13")
hash_well_II <- subset(hash_well_II, subset = HTO_maxID != "Ms.Hashtag-14")

hash_well_II_RNA <- RNAfunction(hash_well_II)
hash_well_II_SCT <- SCTfunction(hash_well_II)

setwd("../hash_well_data/SObjects")
SaveSeuratRds(hash_well_II_RNA, file = "hash_well_II_RNA.RDS")
SaveSeuratRds(hash_well_II_SCT, file = "hash_well_II_SCT.RDS")
rm(list = setdiff(ls(), c("mObject", "RNAfunction", "SCTfunction")))
```

hash_well_III <- all six wells without controls
```{r}
hash_well_III <- mObject

hash_well_III <- subset(hash_well_III, subset = HTO_maxID != "Ms.Hashtag-1")
hash_well_III <- subset(hash_well_III, subset = HTO_maxID != "Ms.Hashtag-2")

hash_well_III_RNA <- RNAfunction(hash_well_III)
hash_well_III_SCT <- SCTfunction(hash_well_III)

setwd("../hash_well_data/SObjects")
SaveSeuratRds(hash_well_III_RNA, file = "hash_well_III_RNA.RDS")
SaveSeuratRds(hash_well_III_SCT, file = "hash_well_III_SCT.RDS")
rm(list = setdiff(ls(), c("mObject", "RNAfunction", "SCTfunction")))
```

hash_well_IV <- five wells; pulled well absent
```{r}
hash_well_IV <- mObject

hash_well_IV <- subset(hash_well_IV, subset = orig.ident != "pool_F")

hash_well_IV_RNA <- RNAfunction(hash_well_IV)
hash_well_IV_SCT <- SCTfunction(hash_well_IV)

setwd("../hash_well_data/SObjects")
SaveSeuratRds(hash_well_IV_RNA, file = "hash_well_IV_RNA.RDS")
SaveSeuratRds(hash_well_IV_SCT, file = "hash_well_IV_SCT.RDS")
rm(list = setdiff(ls(), c("mObject", "RNAfunction", "SCTfunction")))
```

hash_well_V <- only pulled well
```{r}
hash_well_V <- mObject

hash_well_V <- subset(hash_well_V, subset = orig.ident == "pool_F")

# Join and split to correctly name the layers  
DefaultAssay(hash_well_V) <- "RNA"
hash_well_V <- JoinLayers(hash_well_V)
#hash_well_V[["RNA"]] <- split(hash_well_V[["RNA"]], f = hash_well_V$dataset)
# Unintegrated Normalized RNA
hash_well_V <- NormalizeData(hash_well_V)
hash_well_V <- FindVariableFeatures(hash_well_V, nfeatures = 3000)
hash_well_V <- ScaleData(hash_well_V)
hash_well_V <- RunPCA(hash_well_V, verbose = FALSE) 

hash_well_V <- FindNeighbors(hash_well_V, dims = 1:50, reduction = "pca")
hash_well_V <- FindClusters(hash_well_V, resolution = 1, cluster.name = "unint_clusters")
hash_well_V <- RunUMAP(hash_well_V, reduction = "pca", dims = 1:50, reduction.name = "umap.unint")

#hash_well_V_RNA <- RNAfunction(hash_well_V)

setwd("../hash_well_data/SObjects")
SaveSeuratRds(hash_well_V, file = "hash_well_V_RNA.RDS")
#rm(list = setdiff(ls(), c("mObject", "RNAfunction", "SCTfunction")))
```

hash_well_VI <- pulled hashes eliminated
```{r}
hash_well_VI <- mObject

hash_well_VI <- subset(hash_well_VI, subset = orig.id != "AH01")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "AH02")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "BH01")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "BH02")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "CH01")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "CH02")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "DH01")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "DH02")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "EH01")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "EH02")

hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH03")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH04")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH05")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH06")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH07")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH08")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH09")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH12")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH13")
hash_well_VI <- subset(hash_well_VI, subset = orig.id != "FH14")

hash_well_VI_RNA <- RNAfunction(hash_well_VI)
hash_well_VI_SCT <- SCTfunction(hash_well_VI)

setwd("../hash_well_data/SObjects")
SaveSeuratRds(hash_well_VI_RNA, file = "hash_well_VI_RNA.RDS")
SaveSeuratRds(hash_well_VI_SCT, file = "hash_well_VI_SCT.RDS")
rm(list = setdiff(ls(), c("mObject", "RNAfunction", "SCTfunction")))
```
  





